"""
Functions to randomly generate sequential lists and binary trees
"""

import random

from pyske.core.list.slist import SList
from pyske.core.tree.btree import Leaf, Node

__all__ = ['random_list', 'balanced_btree', 'random_btree', 'ill_balanced_btree']


def random_list(frdm, size):
    """
    Generates a random list of the given ``size``.
    Each element is generated by a call to ``frdm``.
    ``size`` should be strictly positive.

    :param frdm: callable
    :param size: int
    :return: list
    """
    assert size >= 0
    res = SList([])
    for _ in range(size):
        res.append(frdm())
    return res


def balanced_btree(frdm, size):
    """
    Generates a random balanced tree of the given ``size``.
    Each element is generated by a call to ``frdm``.
    ``size`` should be strictly positive.

    :param frdm: callable
    :param size: int
    :return: BTree
    """
    current_size = 1
    btr = Leaf(frdm())
    while current_size < size:
        bt2 = btr.map(lambda x: frdm(), lambda x: frdm())
        btr = Node(frdm(), btr, bt2)
        current_size = 2 * current_size + 1
    return btr


def __insert_values_btree(val1, val2, btr):
    # pylint disable=missing-docstring
    if btr.is_leaf():
        return Node(btr.get_value(), Leaf(val1), Leaf(val2))
    # btr.is_node()
    rdm = random.randint(1, 101)
    if rdm > 50:
        # insert left
        left = __insert_values_btree(val1, val2, btr.get_left())
        right = btr.get_right()
        return Node(btr.get_value(), left, right)
    # insert right
    left = btr.get_left()
    right = __insert_values_btree(val1, val2, btr.get_right())
    return Node(btr.get_value(), left, right)


def random_btree(frdm, size):
    """
    Generates a random tree of the given ``size``.
    Each element is generated by a call to ``frdm``.
    ``size`` should be strictly positive.

    :param frdm: callable
    :param size: int
    :return: BTree
    """
    adj_size = (size if size % 2 == 1 else size + 1)
    values = random_list(frdm, adj_size)
    btr = Leaf(values[0])
    for i in range(1, len(values), 2):
        btr = __insert_values_btree(values[i], values[i + 1], btr)
    return btr


def ill_balanced_btree(frdm, size):
    """
    Generates a random list-like tree of the given ``size``.
    Each element is generated by a call to ``frdm``.
    ``size`` should be strictly positive.

    :param frdm: callable
    :param size: int
    :return: BTree
    """
    current_size = 1
    btr = Leaf(frdm())
    while current_size < size:
        btr = Node(frdm(), Leaf(frdm()), btr)
        current_size = current_size + 2
    return btr
